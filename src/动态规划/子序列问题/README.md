## 动态规划-子序列问题

- 最大子数组和
- 最长递增子序列
- 最长连续递增序列
- 最长重复子数组
- 最长公共子序列



### [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

> 给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
>
> **子数组** 是数组中的一个连续部分。

题目解读：子数组定义：就是数组一段连续的序列。这种问题一般 dp[i] ：定义都是**以nums[i]结尾的**。

递推式：

```js
// dp[i]: 第 i 项结尾最大子数组和
// 递推式: dp[i] = Math.max(dp[i - 1] + nums[i], nums[i])
```

### [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

> 给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。
>
> **子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

题目解读：

**子序列**：子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

**递增子序列**：就是后一个数大于前一个数

这种**序列**问题，dp[i] 定义也是以 **nums[i]** 结尾xxx的。

递推式：

```js
dp[i]:  // 以nums[i]结尾的最长递增子序列
dp[i] = Math.max(dp[0], dp[1], ...) + 1; // (nums[i] > nums[j]);

maxLen = Math.max(maxLen, dp[i]);
```

### [674. 最长连续递增序列](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/)

> 给定一个未经排序的整数数组，找到最长且 **连续递增的子序列**，并返回该序列的长度。
>
> **连续递增的子序列** 可以由两个下标 `l` 和 `r`（`l < r`）确定，如果对于每个 `l <= i < r`，都有 `nums[i] < nums[i + 1]` ，那么子序列 `[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]` 就是连续递增子序列。

题目解读：**最长连续子序列**其实就是**子数组**，这个**子数组**是**递增**的。和前面**最大子数组和**不同的是

- 最大子数组和是求**数组和**
- 最长连续递增子序列是求**长度**。

递推式：

```js
dp[i]: // 以下标 nums[i] 结尾的最长递增子序列长度
dp[i] = dp[i - 1] + 1 // nums[i] > nums[i - 1]
maxLen = Math.max(maxLen, dp[i]);
```

### [718. 最长重复子数组](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/)

> 给两个整数数组 `nums1` 和 `nums2` ，返回 *两个数组中 **公共的** 、长度最长的子数组的**长度*** 。

题目解读：记住是**子数组**，要求**公共子数组**。**dp** 数组从**一维**变成**二维**了。这里要求的是**长度**

递推式：

```js
dp[i][j] //	nums1 第 i-1 个元素结尾，nums2 第 j-1 个元素结尾的最长公共子数组长度。

// 初始化 dp, dp[0][0] = 0 可以理解成两个空数组，那么最长公共子数组长度肯定就是 0 了
dp[0][0] = 1

dp[i][j] = dp[i - 1][j - 1] + 1; // nums1[i - 1] === nums2[j - 1]
maxLen = Math.max(maxLen, dp[i][j]);
```

### [1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)

> 给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ，返回 `0` 。
>
> 一个字符串的 **子序列** 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。
>
> - 例如，`"ace"` 是 `"abcde"` 的子序列，但 `"aec"` 不是 `"abcde"` 的子序列。
>
> 两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。

题目解读：这回又是**子序列**了，和**最长重复子数组**最大的区别就是**不是连续的**，还有的一条就是**dp定义不在是以xxx 结尾了**。

递推式：

```js
dp[i][j]：// 长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2
// 的最长公共子序列为dp[i][j]
dp[i][j] = dp[i-1][j-1] + 1 // text1[i] === text2[j]
dp[i][j] = max(dp[i-1][j],dp[i][j])

// dp 初始化，首行和首列均为 0
```



