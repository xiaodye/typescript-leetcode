## 动态规划-完全背包

- 零钱兑换

- 零钱兑换 II
- 组合总和 Ⅳ
- 单词拆分
- 完全平方数

### [322. 零钱兑换](https://leetcode.cn/problems/coin-change/)

> 给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。
>
> 计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。
>
> 你可以认为每种硬币的数量是无限的。

题目解读：有 **n** 个物品，每个物品可以无限次使用，要求凑成金额 **amout**（背包容量），计算并返回可以凑成总金额所需的 **最少的硬币个数** 

递推公式：

```js
dp[i]: 金额为 i 需要的最少硬币
dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1); // i >= coins[j]
```

### [518. 零钱兑换 II](https://leetcode.cn/problems/coin-change-ii/)

> 给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。
>
> 请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 `0` 。
>
> 假设每一种面额的**硬币有无限个**。 
>
> 题目数据保证结果符合 32 位带符号整数。

题目解读：有 **n** 个物品，每个物品可以无限次使用，要求凑成金额 **amout**（背包容量），计算可以**凑成总金额**的硬币**组合数**

递推公式：

```js
dp[i]: 金额为 i 的组合数
dp[i] = sum(dp[i- coins[0]], dp[i - coins[1],...]) // j >= coins[i]
```

### [377. 组合总和 Ⅳ](https://leetcode.cn/problems/combination-sum-iv/)

> 给你一个由 **不同** 整数组成的数组 `nums` ，和一个目标整数 `target` 。请你从 `nums` 中找出并返回总和为 `target` 的元素组合的个数。
>
> 题目数据保证答案符合 32 位整数范围。

题目解读：和**零钱兑换 II**有点像，都是 n 个物品，物品可以使用**无限次**，求凑成 **target** 的**组合数**。

不同点：

- 这里的组合数并不是传统的组合数，应该叫**排列组合数**，比如`1,1,2` 和 `1,2,1` 不是同一种，而在**零钱兑换 II** 是**同一种**。

### [139. 单词拆分](https://leetcode.cn/problems/word-break/)

> 给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。请你判断是否可以利用字典中出现的单词拼接出 `s` 。
>
> **注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

题目解读：有 **n** 个物品，每个物品可以**无限次**使用，判断是否能**凑出 v** （背包容量）

- 单词是**有顺序**的。

递推公式：

```js
dp[i]: 前 i 个字符能被单词表凑出来，对应下标 i - 1
dp[0]: 空字符可以被凑出来 dp[0] = true
dp[i] = dp[i - words[0].length] || dp[i - words[1].length] || ...
```

### [279. 完全平方数](https://leetcode.cn/problems/perfect-squares/)

> 给你一个整数 `n` ，返回 *和为 `n` 的完全平方数的最少数量* 。
>
> **完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。

题目解读：和零钱兑换是同一个思路。有 n 个物品，要求**凑成**和 **m**（背包容量），计算并返回可以凑成和的**最少**完全平方数

递推公式：

```js
dp[i] = Math.min(dp[i - 1*1]+1, dp[i - 2*2]+1, ...)

for (let i = 1; i <= n; i++) {
  for (let j = 0; j * j <= i; j++) {
  	dp[i] = Math.min(dp[i], dp[i - j * j] + 1);
  }
}
```

